<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta charset="utf-8"/>
<meta name="generator" content="Docutils 0.13.1: http://docutils.sourceforge.net/" />
<title>NumberOfDiscIntersections</title>
<style type="text/css">

/* Minimal style sheet for the HTML output of Docutils.                    */
/*                                                                         */
/* :Author: Günter Milde, based on html4css1.css by David Goodger          */
/* :Id: $Id: minimal.css 7952 2016-07-26 18:15:59Z milde $               */
/* :Copyright: © 2015 Günter Milde.                                        */
/* :License: Released under the terms of the `2-Clause BSD license`_,      */
/*    in short:                                                            */
/*                                                                         */
/*    Copying and distribution of this file, with or without modification, */
/*    are permitted in any medium without royalty provided the copyright   */
/*    notice and this notice are preserved.                                */
/*                                                                         */
/*    This file is offered as-is, without any warranty.                    */
/*                                                                         */
/* .. _2-Clause BSD license: http://www.spdx.org/licenses/BSD-2-Clause     */

/* This CSS2.1_ stylesheet defines rules for Docutils elements without    */
/* HTML equivalent. It is required to make the document semantic visible. */
/*                                                                        */
/* .. _CSS2.1: http://www.w3.org/TR/CSS2                                  */
/* .. _validates: http://jigsaw.w3.org/css-validator/validator$link       */

/* alignment of text and inline objects inside block objects*/
.align-left   { text-align: left; }
.align-right  { text-align: right; }
.align-center { clear: both; text-align: center; }
.align-top    { vertical-align: top; }
.align-middle { vertical-align: middle; }
.align-bottom { vertical-align: bottom; }

/* titles */
h1.title, p.subtitle {
  text-align: center;
}
p.admonition-title,
p.topic-title,
p.sidebar-title,
p.rubric,
p.system-message-title {
  font-weight: bold;
}
h1 + p.subtitle,
h1 + p.section-subtitle {
  font-size: 1.6em;
}
h2 + p.section-subtitle { font-size: 1.28em; }
p.subtitle,
p.section-subtitle,
p.sidebar-subtitle {
  font-weight: bold;
  margin-top: -0.5em;
}
p.sidebar-title,
p.rubric {
  font-size: larger;
}
p.rubric { color: maroon; }
a.toc-backref {
  color: black;
  text-decoration: none; }

/* Warnings, Errors */
div.caution p.admonition-title,
div.attention p.admonition-title,
div.danger p.admonition-title,
div.error p.admonition-title,
div.warning p.admonition-title,
div.system-messages h1,
div.error,
span.problematic,
p.system-message-title {
  color: red;
}

/* inline literals */
span.docutils.literal {
  font-family: monospace;
  white-space: pre-wrap;
}
/* do not wraph at hyphens and similar: */
.literal > span.pre { white-space: nowrap; }

/* Lists */

/* compact and simple lists: no margin between items */
.simple  li, .compact li,
.simple  ul, .compact ul,
.simple  ol, .compact ol,
.simple > li p, .compact > li p,
dl.simple > dd, dl.compact > dd {
  margin-top: 0;
  margin-bottom: 0;
}

/* Table of Contents */
div.topic.contents { margin: 0; }
ul.auto-toc {
  list-style-type: none;
  padding-left: 1.5em; }

/* Enumerated Lists */
ol.arabic     { list-style: decimal }
ol.loweralpha { list-style: lower-alpha }
ol.upperalpha { list-style: upper-alpha }
ol.lowerroman { list-style: lower-roman }
ol.upperroman { list-style: upper-roman }

dt span.classifier { font-style: italic }
dt span.classifier:before {
  font-style: normal;
  margin: 0.5em;
  content: ":";
}

/* Field Lists and drivatives */
/* bold field name, content starts on the same line */
dl.field-list > dt,
dl.option-list > dt,
dl.docinfo > dt,
dl.footnote > dt,
dl.citation > dt {
  font-weight: bold;
  clear: left;
  float: left;
  margin: 0;
  padding: 0;
  padding-right: 0.5em;
}
/* Offset for field content (corresponds to the --field-name-limit option) */
dl.field-list > dd,
dl.option-list > dd,
dl.docinfo > dd {
  margin-left:  9em; /* ca. 14 chars in the test examples */
}
/* start field-body on a new line after long field names */
dl.field-list > dd > *:first-child,
dl.option-list > dd > *:first-child
{
  display: inline-block;
  width: 100%;
  margin: 0;
}
/* field names followed by a colon */
dl.field-list > dt:after,
dl.docinfo > dt:after {
  content: ":";
}

/* Bibliographic Fields (docinfo) */
pre.address { font: inherit; }
dd.authors > p { margin: 0; }

/* Option Lists */
dl.option-list { margin-left: 40px; }
dl.option-list > dt { font-weight: normal; }
span.option { white-space: nowrap; }

/* Footnotes and Citations  */
dl.footnote.superscript > dd {margin-left: 1em; }
dl.footnote.brackets > dd {margin-left: 2em; }
dl > dt.label { font-weight: normal; }
a.footnote-reference.brackets:before,
dt.label > span.brackets:before { content: "["; }
a.footnote-reference.brackets:after,
dt.label > span.brackets:after { content: "]"; }
a.footnote-reference.superscript,
dl.footnote.superscript > dt.label {
  vertical-align: super;
  font-size: smaller;
}
dt.label > span.fn-backref { margin-left: 0.2em; }
dt.label > span.fn-backref > a { font-style: italic; }

/* Line Blocks */
div.line-block { display: block; }
div.line-block div.line-block {
  margin-top: 0;
  margin-bottom: 0;
  margin-left: 40px;
}

/* Figures, Images, and Tables */
.figure.align-left,
img.align-left,
object.align-left,
table.align-left {
  margin-right: auto;
}
.figure.align-center,
img.align-center,
object.align-center {
  margin-left: auto;
  margin-right: auto;
  display: block;
}
table.align-center {
  margin-left: auto;
  margin-right: auto;
}
.figure.align-right,
img.align-right,
object.align-right,
table.align-right {
  margin-left: auto;
}
/* reset inner alignment in figures and tables */
div.align-left, div.align-center, div.align-right,
table.align-left, table.align-center, table.align-right
{ text-align: inherit }

/* Admonitions and System Messages */
div.admonition,
div.system-message,
div.sidebar{
  margin: 40px;
  border: medium outset;
  padding-right: 1em;
  padding-left: 1em;
}

/* Sidebar */
div.sidebar {
  width: 30%;
  max-width: 26em;
  float: right;
  clear: right;
}

/* Text Blocks */
div.topic,
pre.literal-block,
pre.doctest-block,
pre.math,
pre.code {
  margin-right: 40px;
  margin-left: 40px;
}
pre.code .ln { color: gray; } /* line numbers */

/* Tables */
table { border-collapse: collapse; }
td, th {
  border-style: solid;
  border-color: silver;
  padding: 0 1ex;
  border-width: thin;
}
td > p:first-child, th > p:first-child { margin-top: 0; }
td > p, th > p { margin-bottom: 0; }

table > caption {
  text-align: left;
  margin-bottom: 0.25em
}

table.borderless td, table.borderless th {
  border: 0;
  padding: 0;
  padding-right: 0.5em /* separate table cells */
}

</style>
<style type="text/css">

/* CSS31_ style sheet for the output of Docutils HTML writers.             */
/* Rules for easy reading and pre-defined style variants.		   */
/*                                                                         */
/* :Author: Günter Milde, based on html4css1.css by David Goodger          */
/* :Id: $Id: plain.css 7952 2016-07-26 18:15:59Z milde $               */
/* :Copyright: © 2015 Günter Milde.                                        */
/* :License: Released under the terms of the `2-Clause BSD license`_,      */
/*    in short:                                                            */
/*                                                                         */
/*    Copying and distribution of this file, with or without modification, */
/*    are permitted in any medium without royalty provided the copyright   */
/*    notice and this notice are preserved.                                */
/*    	     	      	     	 					   */
/*    This file is offered as-is, without any warranty.                    */
/*                                                                         */
/* .. _2-Clause BSD license: http://www.spdx.org/licenses/BSD-2-Clause     */
/* .. _CSS3: http://www.w3.org/TR/CSS3		        		   */


/* Document Structure */
/* ****************** */

/* "page layout" */
body {
  padding: 0 5%;
  margin: 8px 0;
}
div.document {
  line-height:1.3;
  counter-reset: table;
  /* counter-reset: figure; */
  /* avoid long lines --> better reading */
  /* OTOH: lines should not be too short because of missing hyphenation, */
  max-width: 50em;
  margin: auto;
}

/* Sections */

/* Transitions */

hr.docutils {
  width: 80%;
  margin-top: 1em;
  margin-bottom: 1em;
  clear: both;
}

/* Paragraphs               */
/* ==========               */

/* vertical space (parskip) */
p, ol, ul, dl,
div.line-block,
table{
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}
h1, h2, h3, h4, h5, h6,
dl > dd {
  margin-bottom: 0.5em;
}

/* Lists                    */
/* ==========               */

/* Definition Lists         */

dl > dd p:first-child { margin-top: 0; }
/* :last-child is not part of CSS 2.1 (introduced in CSS 3) */
/* dl > dd p:last-child  { margin-bottom: 0; } */

/* lists nested in definition lists */
/* :only-child is not part of CSS 2.1 (introduced in CSS 3) */
dd > ul:only-child, dd > ol:only-child { padding-left: 1em; }

/* Description Lists */
/* styled like in most dictionaries, encyclopedias etc. */
dl.description > dt {
  font-weight: bold;
  clear: left;
  float: left;
  margin: 0;
  padding: 0;
  padding-right: 0.5em;
}

/* Field Lists */

/* example for custom field-name width */
dl.field-list.narrow > dd {
  margin-left: 5em;
}
/* run-in: start field-body on same line after long field names */
dl.field-list.run-in > dd p {
  display: block;
}

/* Bibliographic Fields */

/* generally, bibliographic fields use special definition list dl.docinfo */
/* but dedication and abstract are placed into "topic" divs */
div.abstract p.topic-title {
  text-align: center;
}
div.dedication {
  margin: 2em 5em;
  text-align: center;
  font-style: italic;
}
div.dedication p.topic-title {
  font-style: normal;
}

/* Citations */
dl.citation dt.label {
  font-weight: bold;
}
span.fn-backref {
  font-weight: normal;
}

/* Text Blocks           */
/* ============          */

/* Literal Blocks           */
pre.literal-block, pre.doctest-block,
pre.math, pre.code {
  margin-left: 1.5em;
  margin-right: 1.5em
}

/* Block Quotes             */

blockquote,
div.topic {
  margin-left: 1.5em;
  margin-right: 1.5em
}
blockquote > table,
div.topic > table {
  margin-top: 0;
  margin-bottom: 0;
}
blockquote p.attribution,
div.topic p.attribution {
  text-align: right;
  margin-left: 20%;
}

/* Tables                   */
/* ======                   */

/* th { vertical-align: bottom; } */

table tr { text-align: left; }

/* "booktabs" style (no vertical lines) */
table.booktabs {
  border: 0;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.booktabs * {
  border: 0;
}
table.booktabs th {
  border-bottom: thin solid;
}

/* numbered tables (counter defined in div.document) */
table.numbered > caption:before {
  counter-increment: table;
  content: "Table " counter(table) ": ";
  font-weight: bold;
}

/* Explicit Markup Blocks   */
/* ======================   */

/* Footnotes and Citations  */
/* -----------------------  */

/* line on the left */
dl.footnote {
  padding-left: 1ex;
  border-left: solid;
  border-left-width: thin;
}

/* Directives               */
/* ----------               */

/* Body Elements            */
/* ~~~~~~~~~~~~~            */

/* Images and Figures */

/* let content flow to the side of aligned images and figures */
.figure.align-left,
img.align-left,
object.align-left {
  display: block;
  clear: left;
  float: left;
  margin-right: 1em
}
.figure.align-right,
img.align-right,
object.align-right {
  display: block;
  clear: right;
  float: right;
  margin-left: 1em
}
/* Stop floating sidebars, images and figures at section level 1,2,3 */
h1, h2, h3 { clear: both; }

/* Sidebar */

/* Move into the margin. In a layout with fixed margins, */
/* it can be moved into the margin completely.		 */
div.sidebar {
  width: 30%;
  max-width: 26em;
  margin-left: 1em;
  margin-right: -5.5%;
  background-color: #ffffee ;
}

/* Code                     */

pre.code, code { background-color: #eeeeee }
pre.code .ln { color: gray; } /* line numbers */
/* basic highlighting: for a complete scheme, see */
/* http://docutils.sourceforge.net/sandbox/stylesheets/ */
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

/* Math                     */
/* styled separately (see math.css for math-output=HTML) */

/* Epigraph                 */
/* Highlights               */
/* Pull-Quote               */
/* Compound Paragraph       */
/* Container                */

/* can be styled in a custom stylesheet */

/* Document Header and Footer */

div.footer, div.header {
  clear: both;
  font-size: smaller;
}

/* Inline Markup            */
/* =============            */

/* Emphasis                 */
/*   em                     */
/* Strong Emphasis          */
/*   strong		    */
/* Interpreted Text         */
/*   span.interpreted  	    */
/* Title Reference 	    */
/*   cite		    */
/* Inline Literals          */
/* possible values: normal, nowrap, pre, pre-wrap, pre-line */
/*   span.docutils.literal { white-space: pre-wrap; } */

/* Hyperlink References     */
a { text-decoration: none; }

/* External Targets         */
/*   span.target.external   */
/* Internal Targets  	    */
/*   span.target.internal   */
/* Footnote References      */
/*   a.footnote-reference   */
/* Citation References      */
/*   a.citation-reference   */

</style>
</head>
<body>
<div class="document" id="numberofdiscintersections">
<h1 class="title">NumberOfDiscIntersections</h1>

<p>Compute the number of intersections in a sequence of discs</p>
<div class="section" id="description">
<h1>Description</h1>
<p>We say that the J-th disc and K-th disc intersect if J ≠ K and the J-th and K-th discs have at least one common point (assuming that the discs contain their borders).</p>
<p>The figure below shows discs drawn for N = 6 and A as follows:</p>
<ul class="simple">
<li><p>A[0] = 1</p></li>
<li><p>A[1] = 5</p></li>
<li><p>A[2] = 2</p></li>
<li><p>A[3] = 1</p></li>
<li><p>A[4] = 4</p></li>
<li><p>A[5] = 0</p></li>
</ul>
<img alt="images/NumberOfDiscIntersections.png" src="images/NumberOfDiscIntersections.png" />
<p>There are eleven (unordered) pairs of discs that intersect, namely:</p>
<ul class="simple">
<li><p>discs 1 and 4 intersect, and both intersect with all the other discs;</p></li>
<li><p>disc 2 also intersects with discs 0 and 3.</p></li>
</ul>
<p>Write a function:</p>
<pre class="literal-block">int solution(vector&lt;int&gt; &amp;A);</pre>
<p>that, given an array A describing N discs as explained above, returns the number of (unordered) pairs of intersecting discs. The function should return −1 if the number of intersecting pairs exceeds 10,000,000.</p>
<p>Given array A shown above, the function should return 11, as explained above.</p>
<p>Assume that:</p>
<ul class="simple">
<li><p>N is an integer within the range [0..100,000];</p></li>
<li><p>each element of array A is an integer within the range [0..2,147,483,647].</p></li>
</ul>
<p>Complexity:</p>
<ul class="simple">
<li><p>expected worst-case time complexity is O(N*log(N));</p></li>
<li><p>expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).</p></li>
</ul>
<p>Elements of input arrays can be modified.</p>
</div>
<div class="section" id="o-n-2">
<h1>解答1：O(N^2)</h1>
<p>给定两个以i和j为圆心的圆，那么其半径分别为A[i]和A[j]。由题目描述可知，若一个较大的圆包含另一个圆，那么两者也被认为是相交的。那么，什么条件下，两个圆是相交的呢？</p>
<p>显然，只有当两个圆的半径相加都不如i与j的距离大时，两个圆不相交，除此之外都是相交的。因此，下列条件满足时两圆相交:</p>
<pre class="literal-block">A[i] + A[j] &gt;= j - i, i &lt; j</pre>
<p>上述条件可以改写为:</p>
<pre class="literal-block">A[i] + i &gt;= j - A[j], i &lt; j</pre>
<p>尝试所有可能的i与j组合，遇到符合条件的就记入结果。</p>
</div>
<div class="section" id="o-nlogn">
<h1>解答2：O(NlogN)</h1>
<p>Let's think of this problem graphically. Here is a pictorial representation of the example data given in the solution.</p>
<img alt="images/1.png" src="images/1.png" />
<p>One might notice this kind of a representation seems a bit like what we see in a compiler course. Indeed, we may have some impression that it is sort of a liveness analysis problem, as we seen in register allocation; consider each element of the array A is like a variable. To get how many registers are required for a program, we need to see what is the maximum number of variables that are alive simultaneously. If the actual number of the CPU's registers is not enough, one has to generate the code to escape some variables onto the memory at least temporarily.</p>
<p>So this problem is about liveness. Let's consider the left side of a disc is the beginning of liveness and the right side of a disc is the end of liveness.</p>
<p>Checking how many other discs are 'live' between this regions gives the number of the intersections the disc has with the other discs.</p>
<p>However, this time in this problem, we only need the number of intersections and do not need to enumerate all the combinations. We only have to check the number of the 'live' discs.</p>
<p>If we sort the left limits and right limits of the given discs, we only have to scan the array only once after that.</p>
<p>Here is the score of this approach, the detected time complexity is 'O(N * log(N)) or log(N)', since we have two qsort 'O(N * log(N))' and one for loop to scan the array 'O(N)' (so O(2 * N * log(N) + N), taking the bigger time complexity, it will be O(N * log(N)) ).</p>
<img alt="images/2.png" src="images/2.png" />
<pre class="literal-block">#include &lt;alloca.h&gt;

int compare(const void* a, const void *b)
{
    long long l = *((long long*)a);
    long long r = *((long long*)b);

    if (l == r)
        return 0;
    return l &lt; r ? -1 : 1;
}

int solution(int A[], int N) {
    int memsize = sizeof(long long) * N;
    long long* activate = (long long*)alloca(memsize);
    long long* deactivate = (long long*)alloca(memsize);

    long long i = 0;
    for (; i &lt; N; i++){
        activate[i] = i - A[i];
        deactivate[i] = i + A[i];
    }

    qsort(activate, N, sizeof(long long), compare);
    qsort(deactivate, N, sizeof(long long), compare);

    long long total = 0;

    long long currentActive = 0;
    long long activatedIndex = 0;
    long long deactivatedIndex = 0;

    for (i = 0; i &lt; N; i++){
        while (activatedIndex &lt; N &amp;&amp;
               activate[activatedIndex] &lt;= deactivate[deactivatedIndex]) {
            activatedIndex++;
            currentActive++;
        }

        currentActive--;
        total += currentActive;
        if (total &gt; 10000000)
            return -1;
        deactivatedIndex++;
    }

    return total;
}</pre>
<p>This approach may require some explanation to understand. Let's see what is done graphically. First, as shown in the code, both upper(right) limit and lower(left) limit are computed and sorted, but sorted in different arrays. We don't even pair these two values for each disc, as we don't have to enumerate the combinations of discs that intersect this time.</p>
<img alt="images/3.png" src="images/3.png" />
<p>The smallest number for the upper limit is 'one' as above. So let's focus on this number now. How many discs are 'live' before this A[0] disc 'dies'? It can be easily obtained by checking the lower limit numbers less than 'one'. As the lower limits are also sorted, we only have to slide the current index linearly to get the next smallest value.</p>
<p>Note that we don't need to know the value of a lower limit belong to which disc. What we are checking now is 'the smallest upper limit', which means all the other upper limit values are larger than it. Then, any disc with the lower limit value below 'the smallest upper limit' always has an intersection.</p>
<img alt="images/4.png" src="images/4.png" />
<p>So four discs was 'activated' to live including A[0] itself. Considering this, the number of the active 'intersection' at 'one' is 3. And after A[0] is 'deactivated' to die, there are 3 discs still alive here. As we have checked A[0] already, we can now forget  about it.</p>
<p>Then let's focus, the next smallest upper limit (A[2] or A[3]. Both would result the same answer anyway).</p>
<img alt="images/5.png" src="images/5.png" />
<p>Before reaching 'four' (A[2]), one more disc is activated at 'two' (A[3]). so the live discs when we are checking 'four' (A[2]) increases to 4. So the number of discs that intersects with this time is 3 (4 - 1, as we don't want to count the A[2] disc itself').</p>
<p>One may consider A[0] is still alive indeed, but we already have checked that the combination of A[0] and A[2] in the previous phase.
So lets' count up the number of the intersection we checked so far (3 in the first phase + 3 in this phase = 6, now).</p>
<p>Let's check A[3] now, as it has 'four' the next smallest number.</p>
<img alt="images/6.png" src="images/6.png" />
<p>No new disc is activated in this phase, so as the number of the current live discs are three, the number of the new intersection at this point is 2. As we have seen in the previous phases, we don't have to check if A[0] or A[2] intersects with A[3], since they are already checked. We have checked 3 + 3 + 2 = 8 interactions.</p>
<img alt="images/7.png" src="images/7.png" />
<p>Now let's look at 5 of A[5]. (Indeed, it may need to be emphasized we really don't have to know if this is A[5] or not. We just need to know 'how many discs are 'alive' at a certain upper limit point.)</p>
<p>Right when A[5] is activated to live, it is deactivated to die. So the number of the live discs before the death is 3, and the number of new intersections is 2. We have checked 3 + 3 + 2 + 2 = 10 interactions.</p>
<img alt="images/8.png" src="images/8.png" />
<p>Now let's check the next smallest upper limit 'six' (of A[1]). We have two discs alive before 6, thus the number of new intersections is '1'. We have checked 3 + 3 + 2 + 2 + 1 = 11 interactions.</p>
<img alt="images/9.png" src="images/9.png" />
<p>We reached the biggest upper limit value 'eight'. Only one disc is alive and thus there is no intersection. The final answer we have is 11.</p>
<p>I hope the above graphical representations help the understanding of the solution. It should also be noted again that what we just need was 'the number of the active discs' and so we only have to care about the 'activate' and 'deactivate' events and do not have to care about to which disc each event belong.</p>
<p>Considering this fact, there can be found a solution even better than this.</p>
</div>
<div class="section" id="o-n">
<h1>解答3：O(N)</h1>
<p>I found this solution in the stack overflow.
<a class="reference external" href="http://stackoverflow.com/questions/4801242/algorithm-to-calculate-number-of-intersecting-discs">http://stackoverflow.com/questions/4801242/algorithm-to-calculate-number-of-intersecting-discs</a></p>
<p>This solution is O(N) and does not require any sorting. It also gives 100% score.</p>
<p>To fully understand the solution, we begin from a less efficient solution.</p>
<p>As described in the above solution, note this again: what we are interested in the number of the intersections, and it is not required to enumerate the combinations.</p>
<p>So we care about the liveness; we checked how many discs are still alive when any of them dies.</p>
<p>Considering this, we can prepare two arrays similar as the solution we have seen already, but we use the array to contain the number of activation events and deactivation events at the index [i].</p>
<p>Scanning such arrays from the beginning, we can track how many discs are alive at the index [i] and how many dies there. When we found any disc dies at the index [i], we count up the number of intersection by the_number_of_the_current_active_discs - 1 (which is the number of the intersections between the dying discs and other active discs), and the decrement the number of the active discs as one dies. If two or more discs are dying at the index [i], we repeat the above until there is no more disc that dies at the index.</p>
<p>The code is as below:</p>
<pre class="literal-block">#include &lt;memory.h&gt;
#include &lt;alloca.h&gt;

int solution(int A[], int N) {
    int memsize = sizeof(int) * N;
    int* activated   = (int*)alloca(memsize);
    int* deactivated = (int*)alloca(memsize);

    memset(activated    , 0x00, memsize);
    memset(deactivated  , 0x00, memsize);

    int i;
    // counter the number of activation/deactivation at the index.
    for (i = 0; i &lt; N; i++) {
        // if the lower limit is below 0, consider it as 0.
        // this won't affect the number of activated discs at the index.
        long long lower_lim = i - (long long)A[i];
        lower_lim = (lower_lim &lt; 0) ? 0 : lower_lim;
        activated[lower_lim]++;

        // the same to the upper limit.
        long long upper_lim = i + (long long)A[i];
        upper_lim  = upper_lim &gt; N - 1 ? N - 1 : upper_lim;
        deactivated[upper_lim]++;
    }

    // let's scan the activated/deactivated arrays.
    int total = 0;
    int active = 0;
    for (i = 0; i &lt; N; i++){
        active += activated[i];
        if (active == 0 || deactivated[i] == 0)
            continue;
        // we have at least one deactivated disc at the index 'i'.
        while (deactivated[i] &gt; 0) {
            // active - 1is the number of the new intersection.
            total += active - 1;
            if (total &gt; 10000000)
                return -1;
            // one disc is dead.
            // so decrement the number of active discs.
            active--;
            deactivated[i]--;
        }
    }
    return total;
}</pre>
<p>One might notice what we do is the internal while loop is indeed computing the sequence of numbers with common difference, which can be replaced by a simple formula; think of this, if there is a sequence such as [10, 9, 8, 7,...], we can compute its sum by Sn = n (a + l) / 2, where 'Sn' is the sum, 'n' is the number of terms, and 'a' and 'l' are the first term and the last term respectively.</p>
<p>Modifying the code above in this manner, the best solution can be given.</p>
<img alt="images/10.png" src="images/10.png" />
<pre class="literal-block">#include &lt;memory.h&gt;
#include &lt;alloca.h&gt;

int solution(int A[], int N) {
    int memsize = sizeof(int) * N;
    int* activated   = (int*)alloca(memsize);
    int* deactivated = (int*)alloca(memsize);

    memset(activated,   0x00, memsize);
    memset(deactivated, 0x00, memsize);

    int i;
    // counter the number of activation/deactivation at the index.
    for (i = 0; i &lt; N; i++) {
        // if the lower limit is below 0, consider it as 0.
        // this won't affect the number of activated discs at the index.
        long long lower_lim = i - (long long)A[i];
        lower_lim = (lower_lim &lt; 0) ? 0 : lower_lim;
        activated[lower_lim]++;

        // the same to the upper limit.
        long long upper_lim = i + (long long)A[i];
        upper_lim  = (upper_lim &gt; N - 1) ? N - 1 : upper_lim;
        deactivated[upper_lim]++;
    }

    // let's scan the activated/deactivated arrays.
    int total = 0;
    int active = 0;
    for (i = 0;  i &lt; N; i++) {
        active += activated[i];
        if (active == 0 || deactivated[i] == 0)
            continue;
        // Sn = n * (a + l) / 2
        //      where   Sn  is the sum of the sequence 9, 8, 7, 6, 5 ...
        //              n   is the number of terms  (= deactivated[i])
        //              a   is the first term       (= active - 1)
        //              n   is the last term        (= active - deactivated[i])
        //
        // int sn = deactivated[i] * ( (active - 1) + (active - deactivated[i]) / 2
        int sn = deactivated[i] * (2 * active - 1 - deactivated[i]) / 2;
        total += sn;
        if (total &gt; 10000000){
            return -1;
        }
        active -= deactivated[i];
    }
    return total;

}</pre>
<p>While this problem is very tough and interesting, I still don't have any idea when such a solution can be useful. When you do linear register allocation, you actually have to track each variables and the set of live variables so to decide which variable(s) should be escaped to memory when the number of registers are not enough...</p>
</div>
</div>
</body>
</html>
