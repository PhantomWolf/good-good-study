第一部分 Clones
=======================================================
一个可扩展的(scalable)的web服务，包含很多藏在负载均衡器(load balancer)后面的web服务器。负载均衡器均匀地将负载分配到每个服务器上(理想状态下)，这意味着一个用户多个请求可能是不同的服务器处理的。对于一次请求，不论由哪个服务器实际处理，用户得到的结果都应当是相同的。这引出了可扩展性的第一个原则：

每个服务器都应当包含完全一致的代码，且不将用户相关的数据(比如session、profile照片等)存放在本地磁盘或内存中。

Session应被集中存储到一个能被所有服务器访问到的地方，比如一个外部的数据库或者永久性的缓存(例如redis)，后者比前者拥有更好的性能。“外部”的意思是，这些数据库、缓存不能存放在这些web服务器本身上，而是存放在另外的机器上。

如何部署服务器的新版本？如何将代码的更改发送到所有服务器上？有很多工具可以解决部署问题，例如Capistrano。

将Session“外包”给其他服务器，并在所有服务器上运行相同的代码后，可以从一台服务器上创建一个image文件(Amazon把这叫做Amazon Machine Image)，并用它创建新的服务器实例(instance)。这样，新的服务器实例均会运行最新的代码。

Sticky Session
---------------------------------------
Stick Session开启的情况下，用户在一次会话中，总是被分配到一个固定的服务器，这时我们也可以把session存放在每个服务器的本地磁盘中。然而这样的设计也是有缺点的，如果一台服务器崩溃(例如磁盘坏掉)，那么这台服务器上的所有session信息均会丢失，此服务器上的用户将不得不重新登录，或者重新将商品放入购物车。


第二部分 Database
=======================================================
方法1
---------------------------------------
master-slave replicatiion(主从复制)

sharding

denormalization

SQL tuning

方法2
---------------------------------------
从一开始就反范式，数据库查找中不再使用join，或者使用NoSQL数据库(MongoDB/CouchDB)，在你的应用代码中完成join。


第三部分 Cache
=======================================================
如果数据库查询很多，用户访问网页仍然会很慢。这时需要引入内存缓存(redis、memcached)，永远不要做基于文件的缓存，它让服务器的克隆和自动扩展变得痛苦。

缓存是简单的键值对(key-value pair)存储，它作为一个缓冲层，存在于你的应用与数据存储之间。每当应用读取数据时，应先试图从缓存中读取，仅当缓存中没有时才从主数据源(数据库等)读取。这么做是因为cache的读写要远远快于数据库操作，就算缓存没有命中，其浪费的时间相比数据库操作也是微不足道的。

1 缓存数据库查询
---------------------------------------
最常用的缓存模式。每次做数据库查询时，都将结果存入cache中，并以hash过的SQL语句作为key。下次查询时，先看看缓存中是否已有此查询的结果。

这种方法有几个问题。最主要的问题是缓存过期。当你缓存了复杂的查询结果后，很难删除。当某个缓存结果中的一小部分(例如一个单元格)发生改变时，你需要删除所有可能包含此单元格的缓存结果。

2 缓存对象(object)
---------------------------------------
将你的数据视为对象(object)，正如你在代码中所作的一样(class, instance, etc)。用你的类从数据库中的数据集中组装出实例来，并将其存入缓存中。

例如，类Product里有个data属性，它是个数组，包含Product的价格、文本、图片、评论等信息。data的组装需要调用类Product的多个方法，历经多次数据库请求，很难缓存。可以这么做：当类完成data的组装后，直接将data存入缓存，或者(更好)将整个类的instance存入缓存。这样，当该对象发生改变时，可以轻易从缓存移除该object，并让代码显得更加快速和符合逻辑。

最棒的是，它令异步操作成为了可能。可令专门的服务器负责组装这些对象(object)并存入缓存，你的应用只需使用这些缓存后的object，根本不需要访问数据库了。

一些缓存对象示例：

- 用户会话(user session)。永远不要将用户会话(user session)存入数据库
- 完整渲染的博客文章
- 活动流(activity stream)：某个体最近的一系列活动(在一个网站上)。例如一个SNS上一个用户的一系列帖子；一系列新闻。
- user<->friend relationships


第四部分 Asynchronism(异步)
=======================================================
以买面包为例，你进入面包房，要求一条面包，但面包房里并没有现成的面包。你需要等待2小时，面包才能做好。为了避免这样的“请等一会儿”场景，需要引入异步。

方法1：预处理
---------------------------------------
面包房可以晚上烤面包，白天卖。涉及到web应用，这表示提前做好最耗时的任务(如果可能的话)，并将生成好的东西提供给用户，避免了临时生成内容的时间消耗。

此模型常用于将动态内容转换为静态内容。(例如在一些CMS系统里)网站的页面每次发生变化，都会被预渲染成对应的静态html页面，存储起来。这些预渲染操作常常是定期进行的(例如cron job)。这些预渲染会使网站性能大大提高，并变得非常容易扩展(把静态页面复制到其他服务器上即可)。

方法2：生产者消费者模型
---------------------------------------
回到面包房问题，有时用户会要求在蛋糕上写名字，每个名字都不同。面包房不可能预见客户的名字，也就不可能提前制作出写上名字的蛋糕。于是面包房只能让客户回家，第二天再来取蛋糕。涉及到web服务，这表示异步处理任务。

这里有一个典型的工作流程：

用户在网站上提交了一个计算密集的任务，需要几分钟才能完成。网站前端向任务队列(job queue)发送一个job，并立刻通知用户：工作进行中，请继续浏览其他内容。一些worker不断地检查任务队列(job queue)，发现新任务时就处理该任务，完成后发送“任务完成”信号。前端检查到“任务完成”信号后(比如可以轮训，或基于事件)，通知用户。

这种异步模型叫做生产者消费者模型。生产者(网站前端)将产品(任务)存入队列中，一些消费者(worker)从队列中取出并产品并消耗掉(处理任务)。有名的消息队列有RabbitMQ、ActiveMQ等。
