关系型数据库
======================================================

.. image:: images/database.png

关系型数据库：Relational database management system (RDBMS)

ACID:

- Atomicity: Each transaction is all or nothing
- Consistency: Any transaction will bring the database from one valid state to another
- Isolation: Executing transactions concurrently has the same results as if the transactions were executed serially
- Durability: Once a transaction has been committed, it will remain so

有很多扩展关系型数据库的方法：master-slave replication, master-master replication, federation, sharding, denormalization, and SQL tuning.

复制(replication)
---------------------------------------------
主从复制与主主复制的共同缺点：

- 当一个master崩溃，而它上面新写入的数据还没来得及复制到其他节点上时，可能会丢失数据
- 写操作被回放到slave上。如果有很多写操作，slave们可能会忙于回放写操作(互斥锁)，无暇提供读服务。
- 只读slave越多，你就需要复制更多，导致更大的复制延迟
- 一些系统中，master可以多线程并行写入，但slave上只能单线程回放写操作
- 复制(replication)增加了更多硬件和复杂性

主从复制(master-slave replication)
++++++++++++++++++++++++++++++++++++++
Slave上只能读；Master上可读可写，写操作会被复制到Slave上。Slave也可以复制到更多的slave上，形成一个树状结构。若master下线，系统以read-only方式继续运行，直到一个slave被晋升为master，或者规定了一个新的master。

.. image:: images/database-master-slave-replication.png

缺点：需要额外的逻辑来将slave晋升为master

主主复制(master-master replication)
++++++++++++++++++++++++++++++++++++++
设置多个master，每个均可读写。如果一个master下线，系统继续以读写模式运行。

.. image:: images/database-master-master-replication.png

缺点：

- 你需要一个负载均衡器(否则你就得改写程序逻辑，决定向哪个master写入数据)
- 大多数主主结构的系统，要么只有若一致性，例如只能实现最终一致性(违反ACID)；要么会增加写入操作的延迟(由于同步)。
- 随着写入节点的增加，和延迟的增大，需要解决冲突(Conflict resolution)

Federation
---------------------------------------------

.. image:: images/database-federation.png

Federation(functional partitioning，功能分区)将数据库按照功能划分开。比如把单一数据库分为forums、users、products三个数据库，分布在3个服务器上。分开以后，每个数据库服务器的流量都比以前要少，做复制(replication)时的延迟也更小。此外，内存大小一定时，更小的数据库也能增加缓存命中率，且功能相关的数据存放在一起，增加了数据的本地性(locality)。

我们甚至可以把不同种类的数据库连接在一起，组成一个大的虚拟数据库，例如forums数据库使用PostgreSQL而users使用MySQL。在收到查询后，将起解析为每个数据库的SQL语句，最后将结果组合起来，返回给用户。

缺点：

- 性能下降
- 需要更改代码逻辑
- 需要更多硬件。更加复杂

Sharding
---------------------------------------------

.. image:: images/database-sharding.png

碎片(Sharding)技术将数据分散到多个数据库中，每个数据库仅包含数据的一个子集。与Federation不同的是，每个Shard存放的都是功能上相同的数据。其好处与Federation类似：更小的数据库，更小的读写流量，更少的复制(replication)，更多缓存命中，更小的索引大小(查询更快)。与Federation类似，并没有一个集中的master来对写操作进行序列化，因此写操作可以并行进行。一个shard崩溃，其他shard正常运行(不过你需要添加replication以避免数据丢失)。

对users表进行碎片化的常见方法是，对用户名或ID进行hash(当然也可以根据用户姓氏的首字母，或根据用户的地理位置)。

缺点：

- 需要更改代码逻辑，可能让SQL语句更复杂。
- 有些shard上的数据、流量可能比其他shard要多(比如由于碰巧这个shard上有很多重度用户)。解决办法是对某个key进行一致哈希(consistent hashing)，可以让数据分布更均匀。不用普通hash的原因是，consistent hash在添加hash table的槽位时(对应shard的增加)，仅有K/n个key需要重新hash(K为key的数量，n为槽位数量)。
- 连接多个shard的数据更复杂
- 更多硬件，更复杂

反范式化(Denormalization)
---------------------------------------------
反范式化(Denormalization)试图牺牲一些写性能，换去更好的读性能：通过写入冗余数据来避免表的连接(join)。一些数据库(例如PostgreSQL、Oracle)提供materialized views，来负责存储冗余数据，并保持它们的一致性。

一旦引入了sharding和federation，数据库之间的连接(join)会跟复杂。反范式化(Denormalization)有时可以避免一些复杂的join。在大多数系统中，读操作大大多于写操作(100：1甚至1000：1)。一次引发复杂join的读操作可能会非常耗时。

缺点：

- 数据冗余
- 约束(Constraints)能帮助保持冗余数据保持一致，但增加了数据库的复杂性
- 一个反范式化的数据库写性能可能会相对差一些

SQL调优(SQL tuning)
---------------------------------------------
SQL调优是个很广泛的问题。首先要对数据库做benchmark和profiling，以找出性能瓶颈：

* Benchmark - Simulate high-load situations with tools such as ab.
* Profile - Enable tools such as the slow query log to help track performance issues.

以下介绍可能的优化方法：

Tighten up the schema
++++++++++++++++++++++++++++++++++++++
* MySQL将数据库写入到连续的磁盘块(block)里，加快访问速度
* 使用CHAR替代VARCHAR，前者支持快速、随机访问，后者必须找到字符串结尾，才能进行到下一个字符串(前者直接跳过它的长度即可)
* 使用TEXT来存储大块的文本。TEXT允许boolean search。TEXT是一个指针，指向其内容在磁盘上的位置。
* 使用INT
* 使用DECIMAL来记录钱，避免浮点数表现错误
* 避免存储很大的BLOB，可以存放该对象的位置(例如磁盘路径、URL等)
* VARCHAR(255) is the largest number of characters that can be counted in an 8 bit number, often maximizing the use of a byte in some RDBMS.
* 有些数据库里，NULL不会被索引。因此将列设为NOT NULL可以增加搜索性能。

索引
++++++++++++++++++++++++++++++++++++++
* 有了索引，查询(SELECT, GROUP BY, ORDER BY, JOIN)会更快
* 索引常常是自平衡B树，能保持数据有序，允许log(n)级别的搜索、顺序访问、插入、删除操作。
* 增加索引会让数据保持在内存中，要求更多空间
* 写操作可能会较慢，因为索引也需要被写入(但索引的好处大大多于坏处)
* 加载大量数据时，有时先关掉索引之后再打开会更快。

避免昂贵的join操作
++++++++++++++++++++++++++++++++++++++
使用反范式化

将表分区
++++++++++++++++++++++++++++++++++++++
拆分表，将热点放在不同的表中，有助于让其停留在内存里

调整查询缓存
++++++++++++++++++++++++++++++++++++++
query-cache


NoSQL
======================================================
NoSQL有很多种：key-value、document-store、wide column store、graph database。NoSQL里的数据本来就是反范式的，join一般是在应用代码里完成的。大多数NoSQL缺乏真正的ACID事务，并偏爱最终一致性(eventual consistency)

在CAP定律中，比起一致性，NoSQL更倾向于可用性。BASE常用于描述NoSQL的性质：

* Basically available - the system guarantees availability.
* Soft state - the state of the system may change over time, even without input.
* Eventual consistency - the system will become consistent over a period of time, given that the system doesn't receive input during that period.

在纠结选择SQL还是NoSQL之前，了解一下NoSQL的种类是有帮助的。 

Key-value store
---------------------------------------------
Abstraction: hash table

key-value型NoSQL，例如redis，允许O(1)复杂度的读写操作，且常常用在内存或SSD上。key以字典顺序存储，允许高效地获取一个范围的key。 Key-value stores can allow for storing of metadata with a value.

key-value型提供高性能，常用于简单的数据模型或频繁变化的数据，例如内存中的缓存。由于它只提供有限的操作，复杂性被推给了应用程序。key-value store是document store(有时graph database)的基础。

Document store
---------------------------------------------
Abstraction: key-value store with documents stored as values

document store集中于document(XML，JSON，binary, etc)。一个document存储一个object的所有信息。 Document stores提供API或查询语言来基于document自身的内部结构来查询。 Note, many key-value stores include features for working with a value's metadata, blurring the lines between these two storage types.

Based on the underlying implementation, documents are organized in either collections, tags, metadata, or directories. 尽管document可以被存放到一起，但它们的内部字段可以不同。

MongoDB和CouchDB提供SQL一样的查询语言。DynamoDB同时支持Key-value和Document store。

Document store提供很高的灵活性，常用于频繁变化的数据。

Wide column store
---------------------------------------------
Abstraction: nested map ColumnFamily<RowKey, Columns<ColKey, Value, Timestamp>>

.. image:: images/database-wide-column.png

wide column store的基本存储单元是column(键值对)。column可以被加入到column family里(类似SQL数据库里的table)。Super column families包含多个column family。

Google的BigTable是第一个wide column store。诸如BigTable、HBase、Cassandra的存储以字典顺序存放key，允许高效获取一个范围的key。

Wide column stores提供高可用性和高扩展性，常用于非常大的数据集。

Graph database
---------------------------------------------
Abstraction: graph

.. image:: images/database-graph-database.png

在图形数据库中，每个结点都是一个记录，每条弧都是两个结点之间的关系。图形数据库为以下情况而优化：每个记录与其他记录之间有复杂的关系(例如社交网络)。这项技术相对较新，尚未广泛使用。


SQL vs NoSQL
======================================================
用SQL的原因：

* Structured data
* Strict schema
* Relational data
* Need for complex joins
* Transactions
* Clear patterns for scaling
* More established: developers, community, code, tools, etc
* Lookups by index are very fast

用NoSQL的原因：

* Semi-structured data
* Dynamic or flexible schema
* Non-relational data
* No need for complex joins
* Store many TB (or PB) of data
* Very data intensive workload
* Very high throughput for IOPS

适合NoSQL的数据：

* Rapid ingest of clickstream and log data
* Leaderboard or scoring data
* Temporary data, such as a shopping cart
* Frequently accessed ('hot') tables
* Metadata/lookup tables
