123 Best Time to Buy and Sell Stock III 
=================================================
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most two transactions.

Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).


思路
--------------------------
特点：最多可以进行2次事务（一次买入+一次卖出叫一个事务）；买入之后，必须先卖出，才能再次买入。

表面上看没有太大变化，实际上却让问题复杂化了。

.. image:: prices.jpg

首先，买入与卖出并不一定是相邻的谷与峰。我们可以在某个价格低谷处买入，然后不急着卖出，等到某一个价格很高的高峰再卖出。

其次，第一个事务会影响第二个的结果。假设我们第一次买入后，很久都没有卖出，导致错过了很多价格低谷，耽误了第二次买入，那么第二个事务的利润也会受到影响。由于题目只限制最多进行2次事务，因此还不需要用到动态规划。


O(n^2)算法
--------------------------
第121题中，我们有一个O(n)的算法，可以求只允许单个事务时，最大的利润。我们可以同样的算法来解这个问题。

设我们在第i处第一次卖出股票，根据121题的算法，我们可以用O(n)时间复杂度求出如何根据prices[0..i]的数据，获取最大利润。接下来，我们根据prices[i+1..n-1]的数据，用O(n)时间求出第二个事务的最大利润。

i可能的取值范围是0..n，所以总体的时间复杂度为O(n^2)。


O(n)动态规划
--------------------------
我们需要对prices进行两次遍历。首先反向遍历prices，设下标为i。用max_price变量记录当前遇到的最大价格，那么max_price - prices[i]，就是如果在i处买入股票，可以获得的最大利润(等价格变为max_price时卖出)。

然后正向遍历prices，设下标为j。用min_price变量记录当前遇到的最小价格，那么prices[j] - min_price，就是如果在j处卖出股票，可以获得的最大利润。

之前我们说两个事务会互相干扰，是因为两个事务都从左边开始计算，两个事务的min_price并不通用。现在一个从左计算，一个从右计算，互不干扰。最大的利润，就是两个事务利润相加的最大值。


O(n)算法
--------------------------
由于两个事务相互影响，所以我们并不能单独统计事务1、事务2的利润最大值，再把它们加起来。相反，我们要统计整体的资产。设客户的初始资产为0，买入股票被视为资产减少(负债)，卖出股票被视为资产增多。我们只要想办法让客户在两次买卖后，剩余资产最多，那就是利润最高的方案。我们设置4个变量：buy1、sell1、buy2、sell2。

buy1
    目前为止，客户在第一次买入后，所能达到的最大资产。

sell1
    目前为止，客户在第一次卖出后，所能达到的最大资产。

buy2
    目前为止，客户在第二次买入后，所能达到的最大资产。

sell2
    目前为止，客户在第二次卖出后，所能达到的最大资产。

设当前扫描到的位置为i，四个变量的计算关系为::

    buy1  = max(-prices[i])
    sell1 = max(buy1 + prices[i])
    buy2  = max(sell1 - prices[i])
    sell2 = max(buy2 + prices[i])

注意事项1
~~~~~~~~~~~~~~~~

.. image:: prices.jpg

看价格曲线图可知，获取最高利润的方法是，在第1天买入，第2天卖出，在第3天买入，第4天再卖出。然而，第3天的买入价格低于第1天，当i = 3时，buy1会被更新为0，表示在第3天进行第一次买入。这样会不会引起问题呢？

答案是不会的。虽然buy1被更新为第3天买入，但并不代表sell1、buy2、sell2也会跟着更新，因为仅当结果更大时，这些变量才会更新。就算buy1更新了，用于计算sell1的buy1，说不定是之前的另一个值。

注意事项2
~~~~~~~~~~~~~~~~
若buy1在i处更新，说明在该处进行第一次买入，可以使资产最多；若sell1在i处更新，说明在该处进行第一次卖出，可以使资产最多。buy2、sell2同理。这也隐含了一个限制：一次循环只能有一个变量更新，因为一天只能进行一个动作，如果buy1和sell1同时在i处更新，那就表示在第i天同时进行了买入和卖出操作，这是不允许的。

算法会有这个问题么？答案是不会的。假设buy1在i处更新，那么::

    buy1 = -prices[i]

此时sell1的新值为::

    buy1 + prices[i] = -prices[i] + prices[i] = 0

sell1的初始值就是0，且只在遇到更大的值后才会更新，因此sell1不可能比0小，绝对不会更新。同理，buy2、sell2也不会更新。
