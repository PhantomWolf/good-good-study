Frog Jump蛤蟆过河
================================= 
蛤蟆要过河。河被分为x个位置，每个位置存在或不存在一块石头。蛤蟆可以跳到石头上，却不能跳到水里。已知所有石头的位置stones（增序排列），判断蛤蟆是否能成功过河，即跳到最后一块石头上。

注意：

- 蛤蟆第一次跳跃（从第1块石头到第2块）距离必须为1。
- 如果蛤蟆上次跳跃距离为k，那么下次跳跃距离只能是{k - 1, k , k + 1}中的一个
- 蛤蟆只能向前跳。
- 石头的数量大于等于2，小于1100
- 每个石头的位置为非负整数


动态规划
-----------------------
设n为stones的长度。若d[i][j] == true，就表示蛤蟆可以通过跳跃j距离，到达stones[i]位置。只要d[i][0]到d[i][n-1]中有一个为true，就表示存在一条路线，可以让蛤蟆跳到stones[i]位置。

由于第一跳距离只能为1，所以如果stones[1] != 1，直接返回失败。若stones[1] == 1，那么d[1][1] = true。


DFS、BFS
-----------------------
将石头的位置视为结点，将跳跃的距离作为边。如果将所有路线画出来，我们就能得到一棵树。对其进行深度/广度优先遍历，如果某个叶子结点就是最后一块石头，说明存在一条路线，可以从第一块石头到达最后一块石头。

由于问题只要求我们判断是否可以到达最后一块石头，因此采用深度优先搜索更加合适。从第一块石头开始，每到达一块石头，就将其入栈，每次我们都尽可能跳更远的距离。如果无法继续前进了，且并为到达最后一块石头，说明此路不通，我们需要将结点退栈，换一个小一点的跳跃距离，尝试另一条路线。

广度优先搜索也可以，但由于树的分支繁多，需要消耗大量内存。

优化技巧
-----------------------
已知蛤蟆第一次跳跃距离为1。假设蛤蟆走以下路线stones[0], stones[1], stones[2], ..., stones[i-1], stones[i]，每次都跳最远距离k + 1，那么最后一跳的距离为i，即蛤蟆是跳跃了i距离后到达stones[i]的。(如果蛤蟆中途略过一些石头，那么蛤蟆的最后一跳距离要小于i，因为每跳一次才能+1)。

以上分析的结论是，为了到达stones[i]，蛤蟆最远最远可以跳跃i距离。那么如果stones[i-1]与stones[i]的距离大于i，那么蛤蟆永远不可能跳过去。遇到这种情况应当立刻返回false。
