动态规划
===============================
动态规划是一种算法范式(algorithmic paradigm)，它将复杂的问题分解为较小的子问题，并且存储这些子问题解，以避免重复求解。


性质
-------------------------
以下两个性质确保问题可以用动态规划解决：

重叠子问题
++++++++++++++++++++
像分治法一样，动态规划需要合并子问题的解。动态规划多用于需要重复计算子问题的解的情况，它将子问题的解存入一个数组，之后需要时直接读取，提高了性能。

所以当子问题不需要重复求解时(例如归并排序)，动态规划是没有意义的，因为不需要存储子问题的解。

最优子结构
++++++++++++++++++++
一个问题拥有最优子结构(Optimal substructure)，说明问题可以通过采用其子问题的最优解来解决。


问题
-------------------------
LIS
++++++++++++++++++++
Longest Increasing Subsequence：在一个序列（比如一个数组）中，找出最长的子序列的长度，使其所有元素递增。子序列不要求连续。

状态转移方程：设d[i]为在i处结尾的最长递增子序列的长度。那么有::

    设0 < j < i，若存在arr[j] < arr[i]，那么d[i] = 1 + max(d[j])
                 若不存在这样的j，那么d[i] = 1

可见，我们必须把所有的j尝试一遍，才能知道d[i]的值。要求出d[3]，我们需要求出d[2]、d[1]、d[0]；要求出d[2]，我们需要求出d[1]、d[0]。如果我们用普通的递归法求解，d[1]、d[0]会被重复求值。因此我们用循环的方式，先求较小问题，并用数组d存储它们的结果，避免重复求解。

LCS
++++++++++++++++++++
描述：Longest Common Subsequence：给定2个序列，找出它们最长的公共子序列，求其长度。子序列不要求连续。LCS可用于表示两个字符串的相似度

Edit Distance
++++++++++++++++++++
给定2个字符串str1和str2，str1上可以执行插入一个字符、删除一个字符、替换一个字符这3个操作。问至少需要多少次操作，可以把str1转换为str2。

定义子问题：设str1长度为m，str2长度为n。子问题就是求str1与str2的前缀的edit distance。

递归解
~~~~~~~~~~~~~~
设edit_distance(str1, m, str2, n)为str1与str2的edit distance。

如果str1和str2的最后一个字符相同，那么我们就没必要对这个字符进行任何操作，因此可以将问题转化为一个较小的问题edit_distance(str1, m - 1, str2, n - 1)。

如果str1和str2的最后一个字符不相同，那我们有3种操作可以选，我们需要求操作数最少的一个::

    edit_distance(str1, m, str2, n) == 1 + min(edit_distance(str1, m, str2, n - 1), // 插入
                                               edit_distance(str1, m - 1, str2, n), // 删除
                                               edit_distance(str1, m - 1, str2, n - 1)) // 替换

Min Cost Path
++++++++++++++++++++
给定一个代价矩阵，矩阵中每个元素都表示经过该位置的代价。给定其中一个位置(m, n)，求从(0, 0)到达(m, n)所需的最小代价，以及路线。只能向右、向下或右下前进::

    1 → 2   3
          ↘
    4   8   2
            ↓
    1   5   3

最优子结构
~~~~~~~~~~~~~~
要到达(m, n)，必须要经过3个位置中的1个：(m-1, n-1), (m-1, n), (m, n-1)。所以到达(m, n)的最小代价，等于到达这3个位置中代价的最小值，加上(m, n)的代价。由此，问题转化为子问题的最优解。

重叠子问题
~~~~~~~~~~~~~~
设min_cost(m, n)为到达(m, n)的最小代价，cost为代价矩阵，那么递归解为::

    min_cost(m, n) = cost[m][n] + min(min_cost(m - 1, n - 1),
                                      min_cost(m - 1, n),
                                      min_cost(m, n - 1));

                                    mC(2, 2)
                          /            |           \
                         /             |            \             
                 mC(1, 1)           mC(1, 2)             mC(2, 1)
              /     |     \       /     |     \           /     |     \ 
             /      |      \     /      |      \         /      |       \
       mC(0,0) mC(0,1) mC(1,0) mC(0,1) mC(0,2) mC(1,1) mC(1,0) mC(1,1) mC(2,0) 

可见，有些结点的代价被重复计算。如果问题的规模扩大，重复的结点会更多。因此，我们可以使用动态规划。

Coin Change
++++++++++++++++++++
有数量不限的面值为S = {S1, S2, .., Sm}的硬币，要凑齐N元，有多少种方案。
