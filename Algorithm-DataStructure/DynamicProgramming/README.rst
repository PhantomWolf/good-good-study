动态规划
===============================
动态规划是一种算法范式(algorithmic paradigm)，它将复杂的问题分解为较小的子问题，并且存储这些子问题解，以避免重复求解。


性质
-------------------------
以下两个性质确保问题可以用动态规划解决：

重叠子问题
++++++++++++++++++++
像分治法一样，动态规划需要合并子问题的解。动态规划多用于需要重复计算子问题的解的情况，它将子问题的解存入一个数组，之后需要时直接读取，提高了性能。

所以当子问题不需要重复求解时(例如归并排序)，动态规划是没有意义的，因为不需要存储子问题的解。

最优子结构
++++++++++++++++++++
一个问题拥有最优子结构(Optimal substructure)，说明问题可以通过采用其子问题的最优解来解决。


问题
-------------------------
LIS
++++++++++++++++++++
Longest Increasing Subsequence：在一个序列（比如一个数组）中，找出最长的子序列的长度，使其所有元素递增。子序列不要求连续。

状态转移方程：设d[i]为在i处结尾的最长递增子序列的长度。那么有::

    设0 < j < i，若存在arr[j] < arr[i]，那么d[i] = 1 + max(d[j])
                 若不存在这样的j，那么d[i] = 1

可见，我们必须把所有的j尝试一遍，才能知道d[i]的值。要求出d[3]，我们需要求出d[2]、d[1]、d[0]；要求出d[2]，我们需要求出d[1]、d[0]。如果我们用普通的递归法求解，d[1]、d[0]会被重复求值。因此我们用循环的方式，先求较小问题，并用数组d存储它们的结果，避免重复求解。

LCS
++++++++++++++++++++
Longest Common Subsequence：给定2个序列，找出它们最长的公共子序列，求其长度。子序列不要求连续。

Edit Distance
++++++++++++++++++++
给定2个字符串str1和str2，str1上可以执行插入一个字符、删除一个字符、替换一个字符这3个操作。问至少需要多少次操作，可以把str1转换为str2。

定义子问题：设str1长度为m，str2长度为n。子问题就是求str1与str2的前缀的edit distance。

递归解
~~~~~~~~~~~~~~
设edit_distance(str1, m, str2, n)为str1与str2的edit distance。

如果str1和str2的最后一个字符相同，那么我们就没必要对这个字符进行任何操作，因此可以将问题转化为一个较小的问题edit_distance(str1, m - 1, str2, n - 1)。

如果str1和str2的最后一个字符不相同，那我们有3种操作可以选，我们需要求操作数最少的一个::

    edit_distance(str1, m, str2, n) == 1 + min(edit_distance(str1, m, str2, n - 1), // 插入
                                               edit_distance(str1, m - 1, str2, n), // 删除
                                               edit_distance(str1, m - 1, str2, n - 1)) // 替换
